---
title: Sentry使い方マニュアル - 会計自動化システム
created: 2025-07-20 10:45
updated: 2025-07-20 10:45
tags: [sentry, manual, monitoring, error-tracking, guide]
category: guide
author: Claude & tonychustudio
---

# Sentry使い方マニュアル - 会計自動化システム

## TL;DR

Sentryは自動的にエラーを収集し、パフォーマンスを監視するツールです。開発者は`trackUIAction`、`trackAPICall`などのユーティリティ関数を使用して、重要な操作を監視できます。エラーが発生した場合は、Sentryダッシュボードで詳細を確認し、セッションリプレイで問題を再現できます。

## 目次

1. [実装された機能の一覧表](#実装された機能の一覧表)
2. [取り扱い手順](#取り扱い手順)
3. [考えられるユースケース](#考えられるユースケース)

## 実装された機能の一覧表

### 基本機能

| 機能カテゴリ | 機能名 | 説明 | 使用方法 |
|------------|--------|------|----------|
| **エラートラッキング** | 自動エラーキャプチャ | 未処理のエラーを自動収集 | 自動的に動作 |
| | 手動エラーキャプチャ | 特定のエラーを手動で送信 | `Sentry.captureException(error)` |
| | コンテキスト付きエラー | 詳細情報付きでエラー送信 | `captureErrorWithContext()` |
| **パフォーマンス監視** | UIアクショントラッキング | ボタンクリック等の監視 | `trackUIAction()` |
| | APIコールトラッキング | API通信の監視 | `trackAPICall()` |
| | DB操作トラッキング | データベース処理の監視 | `trackDBOperation()` |
| | ビジネスロジック監視 | カスタム処理の監視 | `trackBusinessOperation()` |
| **ロギング** | 構造化ログ | レベル別のログ記録 | `logger.info()`, `logger.error()` 等 |
| | コンソール統合 | console.logの自動収集 | 自動的に動作 |
| **セッションリプレイ** | エラー時の記録 | エラー発生時の操作記録 | 自動的に動作（100%） |
| | 通常時の記録 | 正常動作時の操作記録 | 自動的に動作（10%） |

### ユーティリティ関数

| 関数名 | 用途 | パラメータ | 戻り値 |
|--------|------|-----------|--------|
| `trackUIAction` | UIアクションの監視 | `operationName`, `attributes`, `callback` | callbackの戻り値 |
| `trackAPICall` | API通信の監視 | `method`, `endpoint`, `callback` | Promise<T> |
| `trackDBOperation` | DB操作の監視 | `operation`, `collection`, `callback` | Promise<T> |
| `trackBusinessOperation` | ビジネスロジックの監視 | `operationName`, `context`, `callback` | Promise<T> |
| `captureErrorWithContext` | 詳細なエラー報告 | `error`, `context` | void |

## 取り扱い手順

### 1. 基本的なエラーハンドリング

#### 自動エラーキャプチャ（設定不要）
```typescript
// 未処理のエラーは自動的にSentryに送信される
function riskyOperation() {
  throw new Error("予期しないエラー"); // 自動的にキャプチャ
}
```

#### 手動エラーキャプチャ
```typescript
import * as Sentry from "@sentry/nextjs";

try {
  // リスクのある処理
  await dangerousOperation();
} catch (error) {
  // Sentryに送信
  Sentry.captureException(error);
  
  // ユーザーにもフィードバック
  alert("エラーが発生しました");
}
```

#### コンテキスト付きエラーキャプチャ
```typescript
import { captureErrorWithContext } from "@/lib/sentry-utils";

try {
  await createInvoice(invoiceData);
} catch (error) {
  captureErrorWithContext(error, {
    operation: "invoice_creation",
    userId: currentUser.id,
    entityId: invoiceData.id,
    entityType: "invoice",
    additionalData: {
      amount: invoiceData.amount,
      customerName: invoiceData.customerName,
    }
  });
}
```

### 2. パフォーマンス監視

#### UIアクションのトラッキング
```typescript
import { trackUIAction } from "@/lib/sentry-utils";

// ボタンクリックの監視
const handleSaveInvoice = () => {
  trackUIAction(
    "Save Invoice",
    {
      invoiceId: currentInvoice.id,
      amount: currentInvoice.amount,
      itemCount: currentInvoice.items.length,
    },
    () => {
      // 実際の保存処理
      saveInvoice(currentInvoice);
    }
  );
};
```

#### API通信のトラッキング
```typescript
import { trackAPICall } from "@/lib/sentry-utils";

// API呼び出しの監視
const fetchInvoices = async () => {
  try {
    const data = await trackAPICall(
      "GET",
      "/api/invoices",
      async () => {
        const response = await fetch("/api/invoices");
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return response.json();
      }
    );
    
    setInvoices(data);
  } catch (error) {
    // エラーは自動的にSentryに送信される
    showErrorMessage("請求書の取得に失敗しました");
  }
};
```

#### データベース操作のトラッキング
```typescript
import { trackDBOperation } from "@/lib/sentry-utils";

// DB操作の監視
const updateCustomer = async (customerId: string, data: any) => {
  const result = await trackDBOperation(
    "update",
    "customers",
    async () => {
      return await db.customers.update({
        where: { id: customerId },
        data: data,
      });
    }
  );
  
  return result;
};
```

#### ビジネスロジックのトラッキング
```typescript
import { trackBusinessOperation } from "@/lib/sentry-utils";

// 複雑な業務処理の監視
const generateMonthlyReport = async (month: string) => {
  const report = await trackBusinessOperation(
    "Generate Monthly Report",
    {
      month: month,
      reportType: "financial",
      includeGraphs: true,
    },
    async () => {
      // レポート生成の複雑な処理
      const data = await fetchMonthlyData(month);
      const analysis = await analyzeData(data);
      const pdf = await generatePDF(analysis);
      return pdf;
    }
  );
  
  return report;
};
```

### 3. ロギング

#### 各種ログレベルの使用
```typescript
import { logger } from "@/lib/sentry-utils";

// トレースレベル（最も詳細）
logger.trace("Function entered", { functionName: "calculateTax", params: { amount: 1000 } });

// デバッグレベル
logger.debug(logger.fmt`Processing invoice ${invoiceId} for customer ${customerId}`);

// 情報レベル（重要なビジネスイベント）
logger.info("Invoice created successfully", {
  invoiceId: "INV-001",
  amount: 50000,
  customerName: "株式会社サンプル",
});

// 警告レベル
logger.warn("API rate limit approaching", {
  currentRequests: 450,
  limit: 500,
  endpoint: "/api/invoices",
});

// エラーレベル
logger.error("Failed to send email notification", {
  recipient: "customer@example.com",
  invoiceId: "INV-001",
  error: "SMTP connection timeout",
});

// 致命的エラー
logger.fatal("Database connection lost", {
  database: "accounting_production",
  lastSuccessfulQuery: new Date().toISOString(),
});
```

### 4. Sentryダッシュボードの使い方

#### アクセス方法
1. [Sentry.io](https://sentry.io)にログイン
2. 組織「effect-cz」を選択
3. プロジェクト「mastra-accounting」を選択

#### Issues（問題）の確認
1. **Issues**タブをクリック
2. フィルターオプション：
   - `is:unresolved` - 未解決の問題
   - `is:regression` - 再発した問題
   - `assigned:me` - 自分に割り当てられた問題
3. 問題をクリックして詳細を確認

#### パフォーマンスの確認
1. **Performance**タブをクリック
2. 確認できる情報：
   - トランザクションの一覧
   - 応答時間の分布
   - スループット
   - エラー率

#### セッションリプレイの確認
1. 特定のエラーを選択
2. **Replay**タブをクリック
3. ユーザーの操作を再生して問題を再現

### 5. アラートの設定

#### 基本的なアラート設定
1. **Alerts**タブから「Create Alert」
2. アラートタイプを選択：
   - Issue Alert（エラー発生時）
   - Metric Alert（パフォーマンス指標）
3. 条件を設定：
   - エラー頻度
   - 影響を受けるユーザー数
   - パフォーマンスしきい値

## 考えられるユースケース

### 1. 開発・デバッグフェーズ

#### ケース1: 新機能の品質確認
```typescript
// 新しい請求書作成機能の監視
const createInvoiceWithTracking = async (invoiceData: InvoiceData) => {
  return trackBusinessOperation(
    "Create Invoice - New Feature",
    {
      feature: "auto-tax-calculation",
      version: "1.0.0",
      customerId: invoiceData.customerId,
    },
    async () => {
      // 新機能のロジック
      const taxCalculated = await calculateTaxAutomatically(invoiceData);
      const invoice = await createInvoice({ ...invoiceData, tax: taxCalculated });
      return invoice;
    }
  );
};
```

#### ケース2: パフォーマンスボトルネックの特定
```typescript
// 遅い処理の分析
const analyzeSlowOperation = async () => {
  return Sentry.startSpan(
    { op: "analysis", name: "Slow Operation Analysis" },
    async (parentSpan) => {
      // 各ステップを個別に計測
      const data = await Sentry.startSpan(
        { op: "db.query", name: "Fetch Large Dataset" },
        () => fetchLargeDataset()
      );
      
      const processed = await Sentry.startSpan(
        { op: "compute", name: "Process Data" },
        () => processData(data)
      );
      
      const result = await Sentry.startSpan(
        { op: "render", name: "Generate Report" },
        () => generateReport(processed)
      );
      
      return result;
    }
  );
};
```

### 2. 本番環境での監視

#### ケース1: 重要な業務フローの監視
```typescript
// 月次請求処理の監視
const runMonthlyBilling = async () => {
  return trackBusinessOperation(
    "Monthly Billing Process",
    {
      month: new Date().toISOString().slice(0, 7),
      customerCount: await getActiveCustomerCount(),
      estimatedInvoices: await getEstimatedInvoiceCount(),
    },
    async () => {
      logger.info("Starting monthly billing process");
      
      const customers = await getActiveCustomers();
      const results = {
        successful: 0,
        failed: 0,
        errors: [],
      };
      
      for (const customer of customers) {
        try {
          await generateMonthlyInvoice(customer);
          results.successful++;
        } catch (error) {
          results.failed++;
          results.errors.push({
            customerId: customer.id,
            error: error.message,
          });
          
          captureErrorWithContext(error, {
            operation: "monthly_billing",
            customerId: customer.id,
            customerName: customer.name,
          });
        }
      }
      
      logger.info("Monthly billing completed", results);
      return results;
    }
  );
};
```

#### ケース2: ユーザー体験の問題検出
```typescript
// フォーム送信の監視
const handleFormSubmit = async (formData: FormData) => {
  const startTime = Date.now();
  
  try {
    await trackUIAction(
      "Submit Customer Form",
      {
        formType: "customer_registration",
        fieldCount: Object.keys(formData).length,
        hasAttachments: formData.attachments?.length > 0,
      },
      async () => {
        const response = await submitCustomerForm(formData);
        
        const duration = Date.now() - startTime;
        if (duration > 3000) {
          logger.warn("Slow form submission", {
            duration,
            customerId: response.customerId,
          });
        }
        
        return response;
      }
    );
    
    showSuccessMessage("登録が完了しました");
  } catch (error) {
    showErrorMessage("登録に失敗しました");
    // エラーは自動的にSentryに送信される
  }
};
```

### 3. トラブルシューティング

#### ケース1: エラーの根本原因調査
```typescript
// エラー発生時の詳細なコンテキスト収集
const investigateError = async (operation: () => Promise<any>) => {
  // 現在の状態を記録
  Sentry.setContext("app_state", {
    currentUser: getCurrentUser(),
    activeFeatures: getActiveFeatures(),
    browserInfo: getBrowserInfo(),
  });
  
  try {
    return await operation();
  } catch (error) {
    // エラー時は追加情報を収集
    Sentry.setContext("error_state", {
      memoryUsage: performance.memory,
      timestamp: new Date().toISOString(),
      lastActions: getLastUserActions(),
    });
    
    throw error;
  }
};
```

#### ケース2: 間欠的な問題の追跡
```typescript
// 再現が困難な問題の監視
const monitorIntermittentIssue = async () => {
  // ブレッドクラムを追加
  Sentry.addBreadcrumb({
    message: "Starting intermittent operation",
    category: "custom",
    level: "info",
    data: {
      conditions: getCurrentConditions(),
    },
  });
  
  try {
    const result = await performProblematicOperation();
    
    // 成功時も記録
    logger.info("Intermittent operation succeeded", {
      conditions: getCurrentConditions(),
      result: result,
    });
    
    return result;
  } catch (error) {
    // 失敗時は詳細な情報と共に記録
    captureErrorWithContext(error, {
      operation: "intermittent_issue",
      conditions: getCurrentConditions(),
      systemState: getSystemState(),
      recentLogs: getRecentLogs(),
    });
    
    throw error;
  }
};
```

### 4. パフォーマンス最適化

#### ケース1: レスポンスタイムの改善
```typescript
// APIレスポンスタイムの最適化追跡
const optimizedApiCall = async (endpoint: string) => {
  return trackAPICall("GET", endpoint, async () => {
    // キャッシュチェック
    const cached = await Sentry.startSpan(
      { op: "cache.get", name: "Check Cache" },
      () => checkCache(endpoint)
    );
    
    if (cached) {
      logger.debug("Cache hit", { endpoint });
      return cached;
    }
    
    // APIコール
    const data = await Sentry.startSpan(
      { op: "http.fetch", name: "Fetch from API" },
      () => fetch(endpoint).then(r => r.json())
    );
    
    // キャッシュ保存
    await Sentry.startSpan(
      { op: "cache.set", name: "Update Cache" },
      () => updateCache(endpoint, data)
    );
    
    return data;
  });
};
```

## まとめ

Sentryを効果的に活用することで：

1. **問題の早期発見** - ユーザーが報告する前にエラーを検知
2. **迅速な問題解決** - 詳細な情報とセッションリプレイで原因特定
3. **継続的な改善** - パフォーマンスデータに基づく最適化
4. **ユーザー体験の向上** - プロアクティブな問題対応

適切なトラッキングとロギングを実装することで、システムの信頼性と品質を大幅に向上させることができます。