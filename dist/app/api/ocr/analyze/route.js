"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.POST = POST;
exports.GET = GET;
const server_1 = require("next/server");
const ai_form_recognizer_1 = require("@azure/ai-form-recognizer");
const ocr_ai_orchestrator_1 = require("@/lib/ocr-ai-orchestrator");
const mongodb_client_1 = require("@/lib/mongodb-client");
const mongodb_1 = require("mongodb");
const stream_1 = require("stream");
const logger_1 = require("@/lib/logger");
async function POST(request) {
    const startTime = Date.now();
    console.log('üéØ [OCR API] OCRÂá¶ÁêÜÈñãÂßã');
    console.log('üìÖ [OCR API] Âá¶ÁêÜÈñãÂßãÊôÇÂàª:', new Date().toISOString());
    try {
        logger_1.logger.debug('[OCR API] Starting OCR analysis...');
        logger_1.logger.debug('[OCR API] Request started at:', new Date().toISOString());
        const formData = await request.formData();
        const file = formData.get('file');
        const documentType = formData.get('documentType') || 'invoice';
        const companyId = formData.get('companyId') || '11111111-1111-1111-1111-111111111111';
        logger_1.logger.debug('[OCR API] File size:', file?.size || 0, 'bytes');
        logger_1.logger.debug('[OCR API] Document type:', documentType);
        if (!file) {
            return server_1.NextResponse.json({ error: '„Éï„Ç°„Ç§„É´„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì' }, { status: 400 });
        }
        // „Éï„Ç°„Ç§„É´„Éê„ÉÉ„Éï„Ç°„Çí‰∏ÄÂ∫¶„Å†„ÅëÂèñÂæóÔºàÂæå„ÅßGridFS„Åß„ÇÇ‰ΩøÁî®Ôºâ
        const fileBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(fileBuffer);
        // Azure Form Recognizer„ÅßÂü∫Êú¨ÁöÑ„Å™OCRÂá¶ÁêÜ
        let azureOcrResult;
        const azureEndpoint = process.env.AZURE_FORM_RECOGNIZER_ENDPOINT;
        const azureKey = process.env.AZURE_FORM_RECOGNIZER_KEY;
        logger_1.logger.debug('[OCR API] Azure config check:', {
            hasEndpoint: !!azureEndpoint,
            endpointValue: azureEndpoint || 'not set',
            hasKey: !!azureKey,
            keyLength: azureKey?.length || 0,
            keyPrefix: azureKey?.substring(0, 10) || 'not set'
        });
        if (azureEndpoint && azureKey && !azureEndpoint.includes('your-fr-endpoint') && !azureKey.includes('your-azure-key')) {
            logger_1.logger.debug('[OCR API] Using Azure Form Recognizer...');
            const client = new ai_form_recognizer_1.DocumentAnalysisClient(azureEndpoint, new ai_form_recognizer_1.AzureKeyCredential(azureKey));
            // fileBuffer„Å®uint8Array„ÅØÊó¢„Å´‰∏ä„ÅßÂèñÂæóÊ∏à„Åø
            // documentType„Å´Âøú„Åò„Å¶„É¢„Éá„É´„ÇíÈÅ∏Êäû
            const modelId = documentType === 'supplier-quote' ? 'prebuilt-invoice' : 'prebuilt-invoice';
            const poller = await client.beginAnalyzeDocument(modelId, uint8Array);
            azureOcrResult = await poller.pollUntilDone();
            const azureElapsed = Date.now() - startTime;
            logger_1.logger.debug('[OCR API] Azure Form Recognizer completed in', azureElapsed, 'ms');
        }
        else {
            logger_1.logger.debug('[OCR API] Azure Form Recognizer not configured properly, using mock data');
            logger_1.logger.debug('[OCR API] Mock data reason:', {
                noEndpoint: !azureEndpoint,
                noKey: !azureKey,
                isTestEndpoint: azureEndpoint?.includes('your-fr-endpoint'),
                isTestKey: azureKey?.includes('your-azure-key')
            });
            // „Çà„ÇäÁèæÂÆüÁöÑ„Å™„É¢„ÉÉ„ÇØ„Éá„Éº„Çø
            azureOcrResult = {
                content: `ÂêàÂêå‰ºöÁ§æ„Ç¢„ÇΩ„Ç¶„Çø„Ç§„Çª„Ç§„Éó„É™„É≥„ÉÜ„Ç£„É≥„Ç∞
„Äíxxx-xxxx Êù±‰∫¨ÈÉΩ„Äá„ÄáÂå∫„Äá„Äá 1-2-3
TEL: 03-xxxx-xxxx FAX: 03-xxxx-xxxx

Ë¶ãÁ©çÊõ∏

Ë¶ãÁ©çÁï™Âè∑: M-2025-001
Áô∫Ë°åÊó•: 2025Âπ¥1Êúà18Êó•

Ê†™Âºè‰ºöÁ§æCROPÂæ°‰∏≠

‰ª∂Âêç: Âç∞Âà∑Áâ©

‰∏ãË®ò„ÅÆÈÄö„ÇäÂæ°Ë¶ãÁ©çÁî≥„Åó‰∏ä„Åí„Åæ„Åô„ÄÇ

ÂìÅÂêç: È†òÂèéÊõ∏Ôºà3ÊûöË§áÂÜô„Éª1ÂÜä50ÁµÑÔºâ
Êï∞Èáè: 1
Âçò‰æ°: 5,000
ÈáëÈ°ç: 5,000

Â∞èË®à: 5,000
Ê∂àË≤ªÁ®é: 500
ÂêàË®àÈáëÈ°ç: 5,500ÂÜÜ

ÂÇôËÄÉ: Á¥çÊúü„ÅØÁô∫Ê≥®ÂæåÁ¥Ñ1ÈÄ±Èñì„Å®„Å™„Çä„Åæ„Åô„ÄÇ`,
                pages: [
                    {
                        pageNumber: 1,
                        lines: [
                            { content: 'ÂêàÂêå‰ºöÁ§æ„Ç¢„ÇΩ„Ç¶„Çø„Ç§„Çª„Ç§„Éó„É™„É≥„ÉÜ„Ç£„É≥„Ç∞' },
                            { content: '„Äíxxx-xxxx Êù±‰∫¨ÈÉΩ„Äá„ÄáÂå∫„Äá„Äá 1-2-3' },
                            { content: 'TEL: 03-xxxx-xxxx FAX: 03-xxxx-xxxx' },
                            { content: 'Ë¶ãÁ©çÊõ∏' },
                            { content: 'Ë¶ãÁ©çÁï™Âè∑: M-2025-001' },
                            { content: 'Áô∫Ë°åÊó•: 2025Âπ¥1Êúà18Êó•' },
                            { content: 'Ê†™Âºè‰ºöÁ§æCROPÂæ°‰∏≠' },
                            { content: '‰ª∂Âêç: Âç∞Âà∑Áâ©' },
                            { content: '‰∏ãË®ò„ÅÆÈÄö„ÇäÂæ°Ë¶ãÁ©çÁî≥„Åó‰∏ä„Åí„Åæ„Åô„ÄÇ' },
                            { content: 'ÂìÅÂêç: È†òÂèéÊõ∏Ôºà3ÊûöË§áÂÜô„Éª1ÂÜä50ÁµÑÔºâ' },
                            { content: 'Êï∞Èáè: 1' },
                            { content: 'Âçò‰æ°: 5,000' },
                            { content: 'ÈáëÈ°ç: 5,000' },
                            { content: 'Â∞èË®à: 5,000' },
                            { content: 'Ê∂àË≤ªÁ®é: 500' },
                            { content: 'ÂêàË®àÈáëÈ°ç: 5,500ÂÜÜ' },
                            { content: 'ÂÇôËÄÉ: Á¥çÊúü„ÅØÁô∫Ê≥®ÂæåÁ¥Ñ1ÈÄ±Èñì„Å®„Å™„Çä„Åæ„Åô„ÄÇ' }
                        ]
                    }
                ],
                fields: {
                    'DocumentNumber': { value: 'M-2025-001' },
                    'Date': { value: '2025-01-18' },
                    'VendorName': { value: 'ÂêàÂêå‰ºöÁ§æ„Ç¢„ÇΩ„Ç¶„Çø„Ç§„Çª„Ç§„Éó„É™„É≥„ÉÜ„Ç£„É≥„Ç∞' },
                    'CustomerName': { value: 'Ê†™Âºè‰ºöÁ§æCROP' },
                    'Total': { value: 5500 }
                },
                tables: []
            };
        }
        // AIÈßÜÂãï„ÅÆOCR„Ç™„Éº„Ç±„Çπ„Éà„É¨„Éº„Çø„Éº „Çí‰ΩøÁî®
        logger_1.logger.debug('[OCR API] Starting AI-driven orchestration...');
        const orchestrator = new ocr_ai_orchestrator_1.OCRAIOrchestrator();
        const structuredData = await orchestrator.orchestrateOCRResult({
            ocrResult: azureOcrResult,
            documentType: documentType,
            companyId: companyId
        });
        const totalElapsed = Date.now() - startTime;
        logger_1.logger.debug('[OCR API] AI orchestration completed successfully in', totalElapsed, 'ms total');
        // ÂÖà„Å´„Éï„Ç°„Ç§„É´„ÇíGridFS„Å´‰øùÂ≠ò
        let gridfsFileId = null;
        try {
            logger_1.logger.debug('[OCR API] Saving file to GridFS...');
            const bucket = await (0, mongodb_client_1.getGridFSBucket)();
            // GridFS„Å´„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
            const uploadStream = bucket.openUploadStream(file.name, {
                metadata: {
                    uploadedAt: new Date(),
                    contentType: file.type,
                    documentType: documentType,
                    companyId: companyId,
                    ocrProcessed: true
                }
            });
            // „Éï„Ç°„Ç§„É´ID„ÇíÂèñÂæó
            gridfsFileId = uploadStream.id.toString();
            logger_1.logger.debug('[OCR API] GridFS file ID:', gridfsFileId);
            // Buffer„ÇíStream„Å´Â§âÊèõ„Åó„Å¶„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
            const readableStream = stream_1.Readable.from(Buffer.from(fileBuffer));
            await new Promise((resolve, reject) => {
                readableStream.pipe(uploadStream)
                    .on('error', reject)
                    .on('finish', resolve);
            });
            logger_1.logger.debug('[OCR API] File saved to GridFS successfully');
        }
        catch (gridfsError) {
            logger_1.logger.error('[OCR API] Error saving to GridFS:', gridfsError);
            // GridFS‰øùÂ≠ò„Å´Â§±Êïó„Åó„Å¶„ÇÇÂá¶ÁêÜ„ÅØÁ∂öË°åÔºàfileId„ÅØnull„ÅÆ„Åæ„ÅæÔºâ
        }
        // MongoDB„Å´ÁµêÊûú„Çí‰øùÂ≠ò
        let mongoDbSaved = false;
        let mongoDbId = null;
        try {
            const { MongoClient } = await Promise.resolve().then(() => __importStar(require('mongodb')));
            const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
            const client = new MongoClient(uri);
            await client.connect();
            const dbName = process.env.MONGODB_DB_NAME || 'accounting';
            const db = client.db(dbName.trim());
            const collection = db.collection('documents');
            // OCRÁµêÊûú„Çí„Éâ„Ç≠„É•„É°„É≥„Éà„Å®„Åó„Å¶‰øùÂ≠ò
            const currentDate = new Date();
            console.log('üìÖ [OCR API] ÁèæÂú®„ÅÆÊó•ÊôÇ:', currentDate.toISOString());
            console.log('üìÖ [OCR API] ÊäΩÂá∫„Åï„Çå„ÅüÊó•‰ªò:', {
                invoiceDate: structuredData.invoiceDate,
                issueDate: structuredData.issueDate,
                receiptDate: structuredData.receiptDate
            });
            // ÈßêËªäÂ†¥Èñ¢ÈÄ£„Éï„Ç£„Éº„É´„Éâ„ÅÆ„É≠„Ç∞
            console.log('üöó [OCR API] ÈßêËªäÂ†¥Èñ¢ÈÄ£„Éï„Ç£„Éº„É´„Éâ:', {
                receiptType: structuredData.receiptType,
                facilityName: structuredData.facilityName,
                entryTime: structuredData.entryTime,
                exitTime: structuredData.exitTime,
                parkingDuration: structuredData.parkingDuration,
                baseFee: structuredData.baseFee,
                additionalFee: structuredData.additionalFee,
                companyName: structuredData.companyName
            });
            const ocrDocument = {
                companyId: companyId,
                type: documentType,
                ocrStatus: 'completed',
                ocrProcessedAt: currentDate,
                ocrResult: structuredData,
                // ‰∏ªË¶Å„Éï„Ç£„Éº„É´„Éâ„ÇíÂ±ïÈñãÔºàË™≠„ÅøÂèñ„ÇäAPI„ÅåÊúüÂæÖ„Åô„Çã„Éï„Ç£„Éº„É´„ÉâÂêç„Å´Âêà„Çè„Åõ„ÇãÔºâ
                documentNumber: structuredData.documentNumber || structuredData.receiptNumber,
                issueDate: structuredData.issueDate || structuredData.invoiceDate,
                vendor_name: structuredData.vendor?.name || structuredData.vendorName,
                vendorName: structuredData.vendor?.name || structuredData.vendorName,
                customer_name: structuredData.customer?.name || structuredData.customerName,
                amount: structuredData.totalAmount?.amount || structuredData.totalAmount,
                // OCRÁµêÊûúAPIÁî®„ÅÆ„Éï„Ç£„Éº„É´„Éâ
                total_amount: structuredData.totalAmount?.amount || structuredData.totalAmount || 0,
                totalAmount: structuredData.totalAmount?.amount || structuredData.totalAmount || 0,
                tax_amount: structuredData.taxAmount || 0,
                taxAmount: structuredData.taxAmount || 0,
                subtotal_amount: structuredData.subtotalAmount || ((structuredData.totalAmount?.amount || structuredData.totalAmount || 0) - (structuredData.taxAmount || 0)),
                receipt_date: structuredData.invoiceDate || structuredData.issueDate || new Date(),
                receipt_number: structuredData.receiptNumber || structuredData.documentNumber || '',
                store_name: structuredData.vendor?.name || structuredData.vendorName || '',
                extracted_text: JSON.stringify(structuredData),
                // ÈßêËªäÂ†¥È†òÂèéÊõ∏Â∞ÇÁî®„Éï„Ç£„Éº„É´„Éâ
                receiptType: structuredData.receiptType,
                facilityName: structuredData.facilityName,
                entryTime: structuredData.entryTime,
                exitTime: structuredData.exitTime,
                parkingDuration: structuredData.parkingDuration,
                baseFee: structuredData.baseFee,
                additionalFee: structuredData.additionalFee,
                companyName: structuredData.companyName,
                // „Åù„ÅÆ‰ªñ„ÅÆ„É°„Çø„Éá„Éº„Çø
                fileName: file.name,
                fileType: file.type,
                fileSize: file.size,
                createdAt: currentDate,
                updatedAt: currentDate,
                // GridFS„Éï„Ç°„Ç§„É´ID„ÇíË®≠ÂÆö
                gridfsFileId: gridfsFileId ? new mongodb_1.ObjectId(gridfsFileId) : null,
                sourceFileId: gridfsFileId ? new mongodb_1.ObjectId(gridfsFileId) : null,
                // „Éï„É©„Ç∞
                linked_document_id: null,
                hiddenFromList: false,
                status: 'active',
                // ÂãòÂÆöÁßëÁõÆ„ÅØÂæå„ÅßÈùûÂêåÊúü„ÅßËøΩÂä†
                category: 'Êú™ÂàÜÈ°û',
                subcategory: null
            };
            const insertResult = await collection.insertOne(ocrDocument);
            // ‰øùÂ≠òÁ¢∫Ë™ç
            const savedDoc = await collection.findOne({ _id: insertResult.insertedId });
            if (savedDoc) {
                mongoDbSaved = true;
                mongoDbId = insertResult.insertedId;
                logger_1.logger.debug('[OCR API] Document saved and verified:', insertResult.insertedId);
                console.log('‚úÖ [OCR API] MongoDB‰øùÂ≠ò„ÉªÁ¢∫Ë™çÊàêÂäü! ID:', insertResult.insertedId);
                // ‰øùÂ≠ò„Åï„Çå„Åü„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆOCRÈñ¢ÈÄ£„Éï„Ç£„Éº„É´„Éâ„ÇíÁ¢∫Ë™ç
                console.log('üîç [OCR API] ‰øùÂ≠ò„Åï„Çå„ÅüOCR„Éï„Ç£„Éº„É´„Éâ:', {
                    vendor_name: savedDoc.vendor_name,
                    receipt_date: savedDoc.receipt_date,
                    category: savedDoc.category,
                    total_amount: savedDoc.total_amount,
                    file_name: savedDoc.fileName,
                    gridfsFileId: savedDoc.gridfsFileId?.toString(),
                    // ÈßêËªäÂ†¥Èñ¢ÈÄ£„Éï„Ç£„Éº„É´„Éâ
                    receiptType: savedDoc.receiptType,
                    facilityName: savedDoc.facilityName,
                    entryTime: savedDoc.entryTime,
                    exitTime: savedDoc.exitTime,
                    parkingDuration: savedDoc.parkingDuration,
                    baseFee: savedDoc.baseFee,
                    additionalFee: savedDoc.additionalFee
                });
            }
            else {
                mongoDbSaved = false;
                console.log('‚ùå [OCR API] MongoDB‰øùÂ≠òÂæå„ÅÆÁ¢∫Ë™ç„Å´Â§±Êïó!');
            }
            console.log('üìÑ [OCR API] ‰øùÂ≠ò„Åó„Åü„Éâ„Ç≠„É•„É°„É≥„Éà:', JSON.stringify({
                _id: insertResult.insertedId,
                companyId: ocrDocument.companyId,
                documentNumber: ocrDocument.documentNumber,
                vendor_name: ocrDocument.vendor_name,
                amount: ocrDocument.amount,
                ocrStatus: ocrDocument.ocrStatus,
                createdAt: ocrDocument.createdAt,
                receipt_date: ocrDocument.receipt_date,
                issueDate: ocrDocument.issueDate,
                gridfsFileId: ocrDocument.gridfsFileId,
                category: ocrDocument.category,
                file_name: ocrDocument.fileName,
                ocrResultDetails: {
                    vendor: structuredData.vendor,
                    items: structuredData.items,
                    notes: structuredData.notes
                }
            }, null, 2));
            await client.close();
            // ÂãòÂÆöÁßëÁõÆAIÊé®Ë´ñ„ÇíÈùûÂêåÊúü„ÅßÂÆüË°åÔºàÈ†òÂèéÊõ∏„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
            if (mongoDbSaved && documentType === 'receipt') {
                try {
                    const { AccountCategoryAI } = await Promise.resolve().then(() => __importStar(require('@/lib/account-category-ai')));
                    const categoryAI = new AccountCategoryAI();
                    const ocrResultForAI = {
                        text: JSON.stringify(structuredData),
                        vendor_name: structuredData.vendor?.name || structuredData.vendorName || '',
                        total_amount: structuredData.totalAmount?.amount || structuredData.totalAmount || 0,
                        items: structuredData.items || []
                    };
                    logger_1.logger.debug('[OCR API] Starting category AI prediction for receipt...');
                    // ÈùûÂêåÊúü„ÅßÂÆüË°åÔºà„É¨„Çπ„Éù„É≥„Çπ„ÇíÂæÖ„Åü„Å™„ÅÑÔºâ
                    categoryAI.predictAccountCategory(ocrResultForAI, companyId).then(async (prediction) => {
                        if (prediction && prediction.confidence >= 0.6) {
                            const { MongoClient } = await Promise.resolve().then(() => __importStar(require('mongodb')));
                            const updateClient = new MongoClient(uri);
                            try {
                                await updateClient.connect();
                                const updateDb = updateClient.db(dbName.trim());
                                const updateCollection = updateDb.collection('documents');
                                await updateCollection.updateOne({ _id: mongoDbId }, {
                                    $set: {
                                        category: prediction.category,
                                        subcategory: prediction.subcategory,
                                        aiPrediction: {
                                            category: prediction.category,
                                            subcategory: prediction.subcategory,
                                            confidence: prediction.confidence,
                                            reasoning: prediction.reasoning,
                                            alternativeCategories: prediction.alternativeCategories,
                                            notes: prediction.notes,
                                            predictionDate: new Date()
                                        }
                                    }
                                });
                                logger_1.logger.debug('[OCR API] Category updated successfully:', prediction.category);
                            }
                            catch (updateError) {
                                logger_1.logger.error('[OCR API] Category update error:', updateError);
                            }
                            finally {
                                await updateClient.close();
                            }
                        }
                    }).catch(error => {
                        logger_1.logger.error('[OCR API] Category prediction error:', error);
                    });
                }
                catch (error) {
                    logger_1.logger.error('[OCR API] AccountCategoryAI initialization error:', error);
                }
            }
        }
        catch (dbError) {
            logger_1.logger.error('[OCR API] MongoDB save error:', dbError);
            console.error('‚ùå [OCR API] MongoDB‰øùÂ≠ò„Ç®„É©„ÉºË©≥Á¥∞:', {
                error: dbError instanceof Error ? dbError.message : dbError,
                stack: dbError instanceof Error ? dbError.stack : undefined,
                mongoUri: process.env.MONGODB_URI ? 'Set' : 'Not set'
            });
            // DB„Ç®„É©„Éº„Åå„ÅÇ„Å£„Å¶„ÇÇÂá¶ÁêÜ„ÅØÁ∂öË°å
        }
        const response = {
            success: true,
            data: structuredData,
            fileId: gridfsFileId, // GridFS„ÅÆ„Éï„Ç°„Ç§„É´ID„ÇíËøî„Åô
            mongoDbId: mongoDbId?.toString(), // MongoDB„ÅÆ„Éâ„Ç≠„É•„É°„É≥„ÉàID
            mongoDbSaved: mongoDbSaved, // MongoDB‰øùÂ≠ò„ÅÆÊàêÂê¶
            message: 'DeepSeek AIÈßÜÂãï„ÅÆOCRËß£Êûê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü',
            processingMethod: 'DeepSeek-AI-driven',
            model: 'deepseek-chat',
            processingTime: {
                total: totalElapsed,
                azure: azureOcrResult ? (Date.now() - startTime) : 0
            }
        };
        console.log('‚úÖ [OCR API] OCRÂá¶ÁêÜÂÆå‰∫ÜÔºÅ„É¨„Çπ„Éù„É≥„Çπ:', JSON.stringify({
            success: response.success,
            documentNumber: structuredData.documentNumber,
            vendor: structuredData.vendor?.name,
            amount: structuredData.totalAmount
        }, null, 2));
        return server_1.NextResponse.json(response);
    }
    catch (error) {
        const totalElapsed = Date.now() - startTime;
        logger_1.logger.error('[OCR API] Error after', totalElapsed, 'ms:', error);
        logger_1.logger.error('[OCR API] Error type:', error?.constructor?.name);
        logger_1.logger.error('[OCR API] Error stack:', error instanceof Error ? error.stack : 'No stack trace');
        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØÁâπÂà•„Å™Âá¶ÁêÜ
        if (error instanceof Error && error.message.includes('timed out')) {
            return server_1.NextResponse.json({
                error: 'OCRÂá¶ÁêÜ„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü',
                details: 'DeepSeek API„ÅÆÂøúÁ≠î„ÅåÈÅÖ„ÅÑ„Åü„ÇÅ„ÄÅÂá¶ÁêÜÊôÇÈñìÂà∂Èôê„ÇíË∂ÖÈÅé„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                processingMethod: 'DeepSeek-AI-driven (timeout)',
                processingTime: totalElapsed
            }, { status: 504 });
        }
        // AI Orchestrator„ÅåÂà©Áî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà
        if (error instanceof Error && error.message.includes('AI Orchestrator is not available')) {
            return server_1.NextResponse.json({
                error: 'AI OCRÂá¶ÁêÜ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
                details: 'DeepSeek API„Ç≠„Éº„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÁÑ°Âäπ„Åß„Åô„ÄÇÁí∞Â¢ÉÂ§âÊï∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
                processingMethod: 'DeepSeek-AI-driven (unavailable)',
                processingTime: totalElapsed,
                debugInfo: {
                    hasDeepSeekKey: !!process.env.DEEPSEEK_API_KEY,
                    deepSeekKeyPrefix: process.env.DEEPSEEK_API_KEY?.substring(0, 10) || 'not set'
                }
            }, { status: 503 });
        }
        // „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº
        return server_1.NextResponse.json({
            error: 'DeepSeek OCRËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü',
            details: error instanceof Error ? error.message : 'Unknown error',
            processingMethod: 'DeepSeek-AI-driven (failed)',
            processingTime: totalElapsed,
            errorType: error?.constructor?.name || 'UnknownError',
            debugInfo: {
                hasDeepSeekKey: !!process.env.DEEPSEEK_API_KEY,
                hasAzureKey: !!process.env.AZURE_FORM_RECOGNIZER_KEY,
                nodeEnv: process.env.NODE_ENV
            }
        }, { status: 500 });
    }
}
async function GET(request) {
    return server_1.NextResponse.json({
        endpoint: 'DeepSeek OCR Analyze',
        method: 'POST',
        description: 'DeepSeek AIÈßÜÂãï„ÅÆOCRËß£Êûê„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà',
        supportedDocumentTypes: ['invoice', 'supplier-quote', 'receipt'],
        model: 'deepseek-chat',
        features: [
            'Êó•Êú¨Ë™û„Éì„Ç∏„Éç„ÇπÊñáÊõ∏„ÅÆÈ´òÁ≤æÂ∫¶Ëß£Êûê',
            'ÂêàÂêå‰ºöÁ§æ„Ç¢„ÇΩ„Ç¶„Çø„Ç§„Çª„Ç§„Éó„É™„É≥„ÉÜ„Ç£„É≥„Ç∞Á≠â„ÅÆ‰ºÅÊ•≠ÂêçÊ≠£Á¢∫Ë™çË≠ò',
            'Âæ°‰∏≠„ÉªÊßò„Å´„Çà„ÇãÈ°ßÂÆ¢„Éª‰ªïÂÖ•ÂÖàËá™ÂãïÂà§Âà•',
            'ÂïÜÂìÅÊòéÁ¥∞„ÅÆÊßãÈÄ†ÂåñÊäΩÂá∫',
            'ÈáëÈ°çË®àÁÆó„ÅÆËá™ÂãïÊ§úË®º',
            'DeepSeek Chat „É¢„Éá„É´„Å´„Çà„ÇãÈ´òÁ≤æÂ∫¶Ëß£Êûê'
        ],
        timestamp: new Date().toISOString()
    });
}
